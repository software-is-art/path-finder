-- ============================================================================
-- PURE MATHEMATICAL HOTT LITERAL CONSTRUCTION
-- ============================================================================
-- This replaces hott-literals-pure.rkt with pure mathematical HoTT notation.
-- Pure constructor building with no host language arithmetic operations.

-- Import dependencies
import types.types
import evaluator.values

-- ============================================================================
-- NATURAL NUMBER LITERALS
-- ============================================================================

-- Build natural number from zero using successor
build-nat : ‚Ñï ‚Üí Value
build-nat := Œª(n : ‚Ñï),
  ‚Ñï-elim(n,
    zero-value,                           -- Base case: 0
    Œª(k : ‚Ñï), Œª(rec : Value), succ-value(rec))  -- Recursive case: succ

-- Common small natural numbers
one : Value := succ-value(zero-value)
two : Value := succ-value(one)
three : Value := succ-value(two)
four : Value := succ-value(three)
five : Value := succ-value(four)
six : Value := succ-value(five)
seven : Value := succ-value(six)
eight : Value := succ-value(seven)
nine : Value := succ-value(eight)
ten : Value := succ-value(nine)

-- Build larger numbers by addition (pure HoTT)
twenty : Value := nat-add(ten, ten)
thirty : Value := nat-add(twenty, ten)
forty : Value := nat-add(thirty, ten)
fifty : Value := nat-add(forty, ten)
hundred : Value := nat-multiply(ten, ten)

-- Natural number addition (pure HoTT)
nat-add : Value ‚Üí Value ‚Üí Value
nat-add := Œª(m n : Value),
  Value-elim(Value, m,
    -- constructor-value case
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "zero"),
        n,  -- 0 + n = n
        if-then-else(Value,
          string-equal?(name, "succ"),
          List-elim(Value, Value, args,
            n,  -- No args (shouldn't happen)
            Œª(pred : Value), Œª(rest : List Value),
              succ-value(nat-add(pred, n))),  -- succ(m) + n = succ(m + n)
          unit-value)),  -- Not a nat
    -- Other cases
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), unit-value,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), unit-value,
    unit-value,
    Œª(content : String), unit-value,
    Œª(effect : Effect), unit-value,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), unit-value,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), unit-value)

-- Natural number multiplication (pure HoTT)
nat-multiply : Value ‚Üí Value ‚Üí Value
nat-multiply := Œª(m n : Value),
  Value-elim(Value, m,
    -- constructor-value case
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "zero"),
        zero-value,  -- 0 √ó n = 0
        if-then-else(Value,
          string-equal?(name, "succ"),
          List-elim(Value, Value, args,
            zero-value,  -- No args
            Œª(pred : Value), Œª(rest : List Value),
              nat-add(n, nat-multiply(pred, n))),  -- succ(m) √ó n = n + (m √ó n)
          unit-value)),
    -- Other cases
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), unit-value,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), unit-value,
    unit-value,
    Œª(content : String), unit-value,
    Œª(effect : Effect), unit-value,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), unit-value,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), unit-value)

-- ============================================================================
-- BOOLEAN LITERALS
-- ============================================================================

-- Boolean literals are already defined in evaluator.values:
-- true-value : Value := constructor-value("‚ÇÅ", nil, ùüö)
-- false-value : Value := constructor-value("‚ÇÄ", nil, ùüö)

-- ============================================================================
-- CHARACTER AND STRING LITERALS
-- ============================================================================

-- Create character from Unicode codepoint
make-char : Value ‚Üí Value
make-char := Œª(codepoint : Value),
  constructor-value("char", cons(codepoint, nil), Char)

-- Common ASCII characters
char-space : Value := make-char(thirty-two)
char-newline : Value := make-char(ten)
char-tab : Value := make-char(nine)
char-zero : Value := make-char(forty-eight)
char-nine : Value := make-char(fifty-seven)
char-A : Value := make-char(sixty-five)
char-Z : Value := make-char(ninety)
char-a : Value := make-char(ninety-seven)
char-z : Value := make-char(one-two-two)

-- Helper numbers for characters
thirty-two : Value := nat-add(thirty, two)
forty-eight : Value := nat-add(forty, eight)
fifty-seven : Value := nat-add(fifty, seven)
sixty-five : Value := nat-add(sixty, five)
ninety : Value := nat-add(nat-multiply(nine, ten), zero-value)
ninety-seven : Value := nat-add(ninety, seven)
one-two-two : Value := nat-add(hundred, nat-add(twenty, two))

-- Empty string
empty-string : Value := constructor-value("empty-string", nil, String)

-- String cons
string-cons : Value ‚Üí Value ‚Üí Value
string-cons := Œª(char str : Value),
  constructor-value("string-cons", cons(char, cons(str, nil)), String)

-- Build string from list of characters
build-string : List Value ‚Üí Value
build-string := Œª(chars : List Value),
  List-elim(chars,
    empty-string,  -- nil case
    Œª(char : Value), Œª(rest : List Value),
      string-cons(char, build-string(rest)))

-- Common string literals
string-true : Value := build-string(cons(make-char(one-one-six), 
                                   cons(make-char(one-one-four),
                                   cons(make-char(one-one-seven),
                                   cons(make-char(one-zero-one), nil)))))

string-false : Value := build-string(cons(make-char(one-zero-two),
                                    cons(make-char(ninety-seven),
                                    cons(make-char(one-zero-eight),
                                    cons(make-char(one-one-five),
                                    cons(make-char(one-zero-one), nil))))))

-- More helper numbers
one-zero-one : Value := nat-add(hundred, one)
one-zero-two : Value := nat-add(hundred, two)
one-zero-eight : Value := nat-add(hundred, eight)
one-one-four : Value := nat-add(hundred, nat-add(ten, four))
one-one-five : Value := nat-add(hundred, nat-add(ten, five))
one-one-six : Value := nat-add(hundred, nat-add(ten, six))
one-one-seven : Value := nat-add(hundred, nat_add(ten, seven))

-- ============================================================================
-- DIGIT TO NAT CONVERSION
-- ============================================================================

-- Convert digit character to natural number
digit-to-nat : Value ‚Üí Value
digit-to-nat := Œª(digit-char : Value),
  Value-elim(Value, digit-char,
    -- constructor-value case
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "char"),
        List-elim(Value, Value, args,
          zero-value,
          Œª(codepoint : Value), Œª(rest : List Value),
            nat-subtract(codepoint, forty-eight)),
        zero-value),
    -- Other cases
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), zero-value,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), zero-value,
    zero-value,
    Œª(content : String), zero-value,
    Œª(effect : Effect), zero-value,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), zero-value,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), zero-value)

-- Natural number subtraction (bounded at zero)
nat-subtract : Value ‚Üí Value ‚Üí Value
nat-subtract := Œª(m n : Value),
  Value-elim(Value, n,
    -- constructor-value case
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "zero"),
        m,  -- m - 0 = m
        if-then-else(Value,
          string-equal?(name, "succ"),
          List-elim(Value, Value, args,
            zero-value,
            Œª(pred-n : Value), Œª(rest : List Value),
              nat-pred(nat-subtract(m, pred-n))),
          zero-value)),
    -- Other cases
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), zero-value,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), zero-value,
    zero-value,
    Œª(content : String), zero-value,
    Œª(effect : Effect), zero-value,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), zero-value,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), zero-value)

-- Natural number predecessor (bounded at zero)
nat-pred : Value ‚Üí Value
nat-pred := Œª(n : Value),
  Value-elim(Value, n,
    -- constructor-value case
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "zero"),
        zero-value,  -- pred(0) = 0
        if-then-else(Value,
          string-equal?(name, "succ"),
          List-elim(Value, Value, args,
            zero-value,
            Œª(pred : Value), Œª(rest : List Value), pred),  -- pred(succ(n)) = n
          zero-value)),
    -- Other cases
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), zero-value,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), zero-value,
    zero-value,
    Œª(content : String), zero-value,
    Œª(effect : Effect), zero-value,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), zero-value,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), zero-value)

-- ============================================================================
-- PARSE DECIMAL NUMBER STRING
-- ============================================================================

-- Parse string of digits to natural number
parse-decimal : Value ‚Üí Value
parse-decimal := Œª(str : Value),
  parse-decimal-acc(str, zero-value)

-- Accumulator version
parse-decimal-acc : Value ‚Üí Value ‚Üí Value
parse-decimal-acc := Œª(str acc : Value),
  Value-elim(Value, str,
    -- constructor-value case
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "empty-string"),
        acc,
        if-then-else(Value,
          string-equal?(name, "string-cons"),
          List-elim(Value, Value, args,
            acc,
            Œª(char : Value), Œª(tail-args : List Value),
              List-elim(Value, Value, tail-args,
                acc,
                Œª(tail : Value), Œª(rest : List Value),
                  let digit := digit-to-nat(char) in
                  let new-acc := nat-add(nat-multiply(acc, ten), digit) in
                  parse-decimal-acc(tail, new-acc))),
          acc)),
    -- Other cases
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), acc,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), acc,
    acc,
    Œª(content : String), acc,
    Œª(effect : Effect), acc,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), acc,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), acc)

-- ============================================================================
-- ADVANCED MATHEMATICAL LITERAL OPERATIONS
-- ============================================================================

-- Integer division (using natural number division)
nat-divide : Value ‚Üí Value ‚Üí Value
nat-divide := Œª(dividend divisor : Value),
  nat-divide-helper(dividend, divisor, zero-value)

-- Division helper with accumulator
nat-divide-helper : Value ‚Üí Value ‚Üí Value ‚Üí Value
nat-divide-helper := Œª(dividend divisor quotient : Value),
  if-then-else(Value,
    nat-less?(dividend, divisor),
    quotient,
    nat-divide-helper(nat-subtract(dividend, divisor), divisor, succ-value(quotient)))

-- Natural number less-than comparison
nat-less? : Value ‚Üí Value ‚Üí Value
nat-less? := Œª(m n : Value),
  Value-elim(Value, m,
    -- constructor-value case
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "zero"),
        Value-elim(Value, n,
          Œª(n-name : String), Œª(n-args : List Value), Œª(n-type : Type),
            if-then-else(Value,
              string-equal?(n-name, "zero"),
              false-value,  -- 0 < 0 is false
              true-value),  -- 0 < succ(_) is true
          Œª(params : List String), Œª(body : AST), Œª(env : Environment), false-value,
          Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), false-value,
          false-value,
          Œª(content : String), false-value,
          Œª(effect : Effect), false-value,
          Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), false-value,
          Œª(type-a type-b : Type), Œª(func quasi-inv : Value), false-value),
        if-then-else(Value,
          string-equal?(name, "succ"),
          List-elim(Value, Value, args,
            false-value,
            Œª(pred-m : Value), Œª(rest : List Value),
              Value-elim(Value, n,
                Œª(n-name : String), Œª(n-args : List Value), Œª(n-type : Type),
                  if-then-else(Value,
                    string-equal?(n-name, "zero"),
                    false-value,  -- succ(_) < 0 is false
                    if-then-else(Value,
                      string-equal?(n-name, "succ"),
                      List-elim(Value, Value, n-args,
                        false-value,
                        Œª(pred-n : Value), Œª(n-rest : List Value),
                          nat-less?(pred-m, pred-n)),
                      false-value)),
                Œª(params : List String), Œª(body : AST), Œª(env : Environment), false-value,
                Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), false-value,
                false-value,
                Œª(content : String), false-value,
                Œª(effect : Effect), false-value,
                Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), false-value,
                Œª(type-a type-b : Type), Œª(func quasi-inv : Value), false-value)),
          false-value)),
    -- Other cases
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), false-value,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), false-value,
    false-value,
    Œª(content : String), false-value,
    Œª(effect : Effect), false-value,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), false-value,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), false-value)

-- ============================================================================
-- RATIONAL NUMBERS (AS PAIRS OF NATURALS)
-- ============================================================================

-- Rational number as pair (numerator, denominator)
make-rational : Value ‚Üí Value ‚Üí Value
make-rational := Œª(numerator denominator : Value),
  constructor-value("rational", cons(numerator, cons(denominator, nil)), Rational)

-- Rational addition: a/b + c/d = (ad + bc)/(bd)
rational-add : Value ‚Üí Value ‚Üí Value
rational-add := Œª(r1 r2 : Value),
  let a := rational-numerator(r1) in
  let b := rational-denominator(r1) in
  let c := rational-numerator(r2) in
  let d := rational-denominator(r2) in
  let numerator := nat-add(nat-multiply(a, d), nat-multiply(b, c)) in
  let denominator := nat-multiply(b, d) in
  make-rational(numerator, denominator)

-- Extract numerator from rational
rational-numerator : Value ‚Üí Value
rational-numerator := Œª(r : Value),
  Value-elim(Value, r,
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "rational"),
        List-elim(Value, Value, args,
          zero-value,
          Œª(num : Value), Œª(rest : List Value), num),
        zero-value),
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), zero-value,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), zero-value,
    zero-value,
    Œª(content : String), zero-value,
    Œª(effect : Effect), zero-value,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), zero-value,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), zero-value)

-- Extract denominator from rational
rational-denominator : Value ‚Üí Value
rational-denominator := Œª(r : Value),
  Value-elim(Value, r,
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "rational"),
        List-elim(Value, Value, args,
          one,
          Œª(num : Value), Œª(rest : List Value),
            List-elim(Value, Value, rest,
              one,
              Œª(den : Value), Œª(final : List Value), den)),
        one),
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), one,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), one,
    one,
    Œª(content : String), one,
    Œª(effect : Effect), one,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), one,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), one)

-- ============================================================================
-- COMPILE-TIME LITERAL EVALUATION
-- ============================================================================

-- Evaluate numeric literal at compile time for constant folding
eval-literal-constant : Value ‚Üí Value
eval-literal-constant := Œª(lit : Value),
  Value-elim(Value, lit,
    -- constructor-value case
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "literal-nat"),
        List-elim(Value, Value, args,
          zero-value,
          Œª(val : Value), Œª(rest : List Value), val),
        if-then-else(Value,
          string-equal?(name, "literal-string"),
          List-elim(Value, Value, args,
            empty-string,
            Œª(val : Value), Œª(rest : List Value), val),
          lit)),
    -- Other cases: return as-is
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), lit,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), lit,
    lit,
    Œª(content : String), lit,
    Œª(effect : Effect), lit,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), lit,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), lit)

-- Create literal wrapper for compile-time constants
make-literal-nat : Value ‚Üí Value
make-literal-nat := Œª(n : Value),
  constructor-value("literal-nat", cons(n, nil), LiteralType)

make-literal-string : Value ‚Üí Value
make-literal-string := Œª(s : Value),
  constructor-value("literal-string", cons(s, nil), LiteralType)

make-literal-bool : Value ‚Üí Value
make-literal-bool := Œª(b : Value),
  constructor-value("literal-bool", cons(b, nil), LiteralType)

-- ============================================================================
-- DECIMAL-TO-PEANO: CORE CONVERSION FUNCTION
-- ============================================================================

-- Primary function used by Rust VM for number parsing
-- Converts digit sequence to Peano natural number
decimal-to-peano : Value ‚Üí Value
decimal-to-peano := Œª(digit-seq : Value),
  Value-elim(Value, digit-seq,
    -- constructor-value case
    Œª(name : String), Œª(args : List Value), Œª(type : Type),
      if-then-else(Value,
        string-equal?(name, "digit-sequence"),
        List-elim(Value, Value, args,
          zero-value,
          Œª(digit-string : Value), Œª(rest : List Value),
            parse-decimal(digit-string)),
        zero-value),
    -- Other cases
    Œª(params : List String), Œª(body : AST), Œª(env : Environment), zero-value,
    Œª(name : String), Œª(arity : ‚Ñï), Œª(type : Type), zero-value,
    zero-value,
    Œª(content : String), zero-value,
    Œª(effect : Effect), zero-value,
    Œª(type : Type), Œª(start end : Value), Œª(proof : Proof), zero-value,
    Œª(type-a type-b : Type), Œª(func quasi-inv : Value), zero-value)

-- This establishes pure mathematical literal construction for PathFinder