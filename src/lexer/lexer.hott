-- ============================================================================
-- PURE HOTT LEXER IMPLEMENTATION
-- ============================================================================
-- Mathematical lexical analysis using only HoTT constructors
-- Character-by-character tokenization with formal state transitions

import effects.effects
import core.operations
import types.string

-- ============================================================================
-- TOKEN TYPES AS HOTT INDUCTIVE TYPE
-- ============================================================================

-- Complete token classification
data TokenType : ùí∞‚ÇÄ where
  -- Delimiters
  lparen : TokenType
  rparen : TokenType
  lbracket : TokenType
  rbracket : TokenType
  lbrace : TokenType
  rbrace : TokenType
  
  -- Operators and symbols
  plus : TokenType
  minus : TokenType
  multiply : TokenType
  divide : TokenType
  equal : TokenType
  less-than : TokenType
  greater-than : TokenType
  arrow : TokenType
  
  -- Keywords
  lambda-kw : TokenType
  let-kw : TokenType
  in-kw : TokenType
  if-kw : TokenType
  then-kw : TokenType
  else-kw : TokenType
  data-kw : TokenType
  where-kw : TokenType
  import-kw : TokenType
  
  -- Literals
  number-lit : TokenType
  string-lit : TokenType
  char-lit : TokenType
  bool-lit : TokenType
  
  -- Identifiers
  identifier : TokenType
  constructor-id : TokenType
  
  -- Whitespace and comments
  whitespace : TokenType
  comment : TokenType
  
  -- Special
  eof : TokenType
  invalid : TokenType

-- ============================================================================
-- TOKEN STRUCTURE
-- ============================================================================

-- Token with value and position information
data Token : ùí∞‚ÇÄ where
  token : 
    (type : TokenType) ‚Üí
    (value : String) ‚Üí
    (line : ‚Ñï) ‚Üí
    (column : ‚Ñï) ‚Üí
    (position : ‚Ñï) ‚Üí
    Token

-- Token accessors
token-type : Token ‚Üí TokenType
token-type = Œª(t : Token),
  match t with
  | token type _ _ _ _ => type

token-value : Token ‚Üí String
token-value = Œª(t : Token),
  match t with
  | token _ value _ _ _ => value

token-line : Token ‚Üí ‚Ñï
token-line = Œª(t : Token),
  match t with
  | token _ _ line _ _ => line

token-column : Token ‚Üí ‚Ñï
token-column = Œª(t : Token),
  match t with
  | token _ _ _ column _ => column

token-position : Token ‚Üí ‚Ñï
token-position = Œª(t : Token),
  match t with
  | token _ _ _ _ position => position

-- ============================================================================
-- LEXER STATE
-- ============================================================================

-- Lexer state tracking input position and context
data LexerState : ùí∞‚ÇÄ where
  lexer-state :
    (input : String) ‚Üí
    (position : ‚Ñï) ‚Üí
    (line : ‚Ñï) ‚Üí
    (column : ‚Ñï) ‚Üí
    LexerState

-- State accessors
state-input : LexerState ‚Üí String
state-input = Œª(state : LexerState),
  match state with
  | lexer-state input _ _ _ => input

state-position : LexerState ‚Üí ‚Ñï
state-position = Œª(state : LexerState),
  match state with
  | lexer-state _ position _ _ => position

state-line : LexerState ‚Üí ‚Ñï
state-line = Œª(state : LexerState),
  match state with
  | lexer-state _ _ line _ => line

state-column : LexerState ‚Üí ‚Ñï
state-column = Œª(state : LexerState),
  match state with
  | lexer-state _ _ _ column => column

-- ============================================================================
-- CHARACTER CLASSIFICATION
-- ============================================================================

-- Character classification predicates
char-is-digit : Char ‚Üí ùüö
char-is-digit = Œª(ch : Char),
  char-eliminator ch (Œª(codepoint : ‚Ñï),
    bool-and 
      (nat-greater-equal codepoint (char-code-0))
      (nat-less-equal codepoint (char-code-9)))

char-is-alpha : Char ‚Üí ùüö
char-is-alpha = Œª(ch : Char),
  char-eliminator ch (Œª(codepoint : ‚Ñï),
    bool-or
      (bool-and 
        (nat-greater-equal codepoint (char-code-A))
        (nat-less-equal codepoint (char-code-Z)))
      (bool-and
        (nat-greater-equal codepoint (char-code-a))
        (nat-less-equal codepoint (char-code-z))))

char-is-alphanumeric : Char ‚Üí ùüö
char-is-alphanumeric = Œª(ch : Char),
  bool-or (char-is-alpha ch) (char-is-digit ch)

char-is-whitespace : Char ‚Üí ùüö
char-is-whitespace = Œª(ch : Char),
  char-eliminator ch (Œª(codepoint : ‚Ñï),
    bool-or
      (nat-equal codepoint (char-code-space))
      (bool-or
        (nat-equal codepoint (char-code-tab))
        (bool-or
          (nat-equal codepoint (char-code-newline))
          (nat-equal codepoint (char-code-return)))))

char-is-symbol-start : Char ‚Üí ùüö
char-is-symbol-start = Œª(ch : Char),
  char-eliminator ch (Œª(codepoint : ‚Ñï),
    bool-or 
      (char-is-alpha ch)
      (bool-or
        (nat-equal codepoint (char-code-underscore))
        (bool-or
          (nat-equal codepoint (char-code-question))
          (nat-equal codepoint (char-code-dollar)))))

char-is-symbol-cont : Char ‚Üí ùüö
char-is-symbol-cont = Œª(ch : Char),
  bool-or
    (char-is-symbol-start ch)
    (bool-or
      (char-is-digit ch)
      (char-is-symbol-char ch))

char-is-symbol-char : Char ‚Üí ùüö
char-is-symbol-char = Œª(ch : Char),
  char-eliminator ch (Œª(codepoint : ‚Ñï),
    bool-or
      (nat-equal codepoint (char-code-plus))
      (bool-or
        (nat-equal codepoint (char-code-minus))
        (bool-or
          (nat-equal codepoint (char-code-star))
          (bool-or
            (nat-equal codepoint (char-code-slash))
            (bool-or
              (nat-equal codepoint (char-code-equal))
              (bool-or
                (nat-equal codepoint (char-code-less))
                (bool-or
                  (nat-equal codepoint (char-code-greater))
                  (nat-equal codepoint (char-code-exclamation)))))))))

-- ============================================================================
-- CHARACTER CODE CONSTANTS
-- ============================================================================

-- ASCII character codes as natural numbers
char-code-0 : ‚Ñï := nat-from-decimal (cons d4 (cons d8 (nil Digit)))
char-code-9 : ‚Ñï := nat-from-decimal (cons d5 (cons d7 (nil Digit)))
char-code-A : ‚Ñï := nat-from-decimal (cons d6 (cons d5 (nil Digit)))
char-code-Z : ‚Ñï := nat-from-decimal (cons d9 (cons d0 (nil Digit)))
char-code-a : ‚Ñï := nat-from-decimal (cons d9 (cons d7 (nil Digit)))
char-code-z : ‚Ñï := nat-from-decimal (cons d1 (cons d2 (cons d2 (nil Digit))))

char-code-space : ‚Ñï := nat-from-decimal (cons d3 (cons d2 (nil Digit)))
char-code-tab : ‚Ñï := nat-from-decimal (cons d9 (nil Digit))
char-code-newline : ‚Ñï := nat-from-decimal (cons d1 (cons d0 (nil Digit)))
char-code-return : ‚Ñï := nat-from-decimal (cons d1 (cons d3 (nil Digit)))

char-code-lparen : ‚Ñï := nat-from-decimal (cons d4 (cons d0 (nil Digit)))
char-code-rparen : ‚Ñï := nat-from-decimal (cons d4 (cons d1 (nil Digit)))
char-code-lbracket : ‚Ñï := nat-from-decimal (cons d9 (cons d1 (nil Digit)))
char-code-rbracket : ‚Ñï := nat-from-decimal (cons d9 (cons d3 (nil Digit)))
char-code-lbrace : ‚Ñï := nat-from-decimal (cons d1 (cons d2 (cons d3 (nil Digit))))
char-code-rbrace : ‚Ñï := nat-from-decimal (cons d1 (cons d2 (cons d5 (nil Digit))))

char-code-plus : ‚Ñï := nat-from-decimal (cons d4 (cons d3 (nil Digit)))
char-code-minus : ‚Ñï := nat-from-decimal (cons d4 (cons d5 (nil Digit)))
char-code-star : ‚Ñï := nat-from-decimal (cons d4 (cons d2 (nil Digit)))
char-code-slash : ‚Ñï := nat-from-decimal (cons d4 (cons d7 (nil Digit)))
char-code-equal : ‚Ñï := nat-from-decimal (cons d6 (cons d1 (nil Digit)))
char-code-less : ‚Ñï := nat-from-decimal (cons d6 (cons d0 (nil Digit)))
char-code-greater : ‚Ñï := nat-from-decimal (cons d6 (cons d2 (nil Digit)))

char-code-underscore : ‚Ñï := nat-from-decimal (cons d9 (cons d5 (nil Digit)))
char-code-question : ‚Ñï := nat-from-decimal (cons d6 (cons d3 (nil Digit)))
char-code-dollar : ‚Ñï := nat-from-decimal (cons d3 (cons d6 (nil Digit)))
char-code-exclamation : ‚Ñï := nat-from-decimal (cons d3 (cons d3 (nil Digit)))

char-code-quote : ‚Ñï := nat-from-decimal (cons d3 (cons d4 (nil Digit)))
char-code-dquote : ‚Ñï := nat-from-decimal (cons d3 (cons d4 (nil Digit)))
char-code-backslash : ‚Ñï := nat-from-decimal (cons d9 (cons d2 (nil Digit)))

-- ============================================================================
-- LEXER STATE OPERATIONS
-- ============================================================================

-- Create initial lexer state
make-lexer-state : String ‚Üí LexerState
make-lexer-state = Œª(input : String),
  lexer-state input zero (succ zero) (succ zero)

-- Get current character at position
current-char : LexerState ‚Üí Option Char
current-char = Œª(state : LexerState),
  let input : String := state-input state in
  let pos : ‚Ñï := state-position state in
  string-char-at input pos

-- Advance position by one character
advance-position : LexerState ‚Üí LexerState
advance-position = Œª(state : LexerState),
  let current : Option Char := current-char state in
  option-eliminator current
    -- End of input: return state unchanged
    state
    -- Character found: advance appropriately
    (Œª(ch : Char),
      let input : String := state-input state in
      let pos : ‚Ñï := state-position state in
      let line : ‚Ñï := state-line state in
      let col : ‚Ñï := state-column state in
      char-eliminator ch (Œª(codepoint : ‚Ñï),
        bool-eliminator (nat-equal codepoint char-code-newline)
          -- Not newline: advance column
          (lexer-state input (succ pos) line (succ col))
          -- Newline: advance line, reset column
          (lexer-state input (succ pos) (succ line) (succ zero))))

-- Check if at end of input
at-end : LexerState ‚Üí ùüö
at-end = Œª(state : LexerState),
  option-eliminator (current-char state)
    ùüö-true                               -- No current character: at end
    (Œª(_ : Char), ùüö-false)              -- Has character: not at end

-- ============================================================================
-- TOKEN RECOGNITION
-- ============================================================================

-- Main tokenization function
tokenize : String ‚Üí List Token
tokenize = Œª(input : String),
  let initial-state : LexerState := make-lexer-state input in
  tokenize-loop initial-state (nil Token)

-- Tokenization loop
tokenize-loop : LexerState ‚Üí List Token ‚Üí List Token
tokenize-loop = Œª(state : LexerState), Œª(acc : List Token),
  bool-eliminator (at-end state)
    -- At end: return accumulated tokens with EOF
    (let eof-token : Token := token eof empty-string (state-line state) (state-column state) (state-position state) in
     list-reverse (cons eof-token acc))
    
    -- Not at end: tokenize next token
    (let token-result : (Token √ó LexerState) := next-token state in
     let next-tok : Token := fst token-result in
     let next-state : LexerState := snd token-result in
     tokenize-loop next-state (cons next-tok acc))

-- Recognize next token
next-token : LexerState ‚Üí (Token √ó LexerState)
next-token = Œª(state : LexerState),
  let current : Option Char := current-char state in
  option-eliminator current
    -- End of input: EOF token
    (let eof-tok : Token := token eof empty-string (state-line state) (state-column state) (state-position state) in
     (eof-tok, state))
    
    -- Character available: classify and tokenize
    (Œª(ch : Char),
      bool-eliminator (char-is-whitespace ch)
        -- Whitespace: tokenize whitespace run
        (tokenize-whitespace state)
        
        (bool-eliminator (char-equal ch (char char-code-lparen))
          -- Left parenthesis
          (let tok : Token := token lparen (char-to-string ch) (state-line state) (state-column state) (state-position state) in
           (tok, advance-position state))
          
          (bool-eliminator (char-equal ch (char char-code-rparen))
            -- Right parenthesis
            (let tok : Token := token rparen (char-to-string ch) (state-line state) (state-column state) (state-position state) in
             (tok, advance-position state))
            
            (bool-eliminator (char-is-digit ch)
              -- Number: tokenize numeric literal
              (tokenize-number state)
              
              (bool-eliminator (char-is-symbol-start ch)
                -- Identifier or keyword: tokenize symbol
                (tokenize-symbol state)
                
                (bool-eliminator (char-equal ch (char char-code-dquote))
                  -- String literal: tokenize quoted string
                  (tokenize-string state)
                  
                  -- Single character operators
                  (tokenize-single-char state)))))))

-- ============================================================================
-- SPECIALIZED TOKEN RECOGNITION
-- ============================================================================

-- Tokenize whitespace run
tokenize-whitespace : LexerState ‚Üí (Token √ó LexerState)
tokenize-whitespace = Œª(state : LexerState),
  let ws-result : (String √ó LexerState) := consume-while state char-is-whitespace in
  let ws-value : String := fst ws-result in
  let new-state : LexerState := snd ws-result in
  let tok : Token := token whitespace ws-value (state-line state) (state-column state) (state-position state) in
  (tok, new-state)

-- Tokenize numeric literal
tokenize-number : LexerState ‚Üí (Token √ó LexerState)
tokenize-number = Œª(state : LexerState),
  let num-result : (String √ó LexerState) := consume-while state char-is-digit in
  let num-value : String := fst num-result in
  let new-state : LexerState := snd num-result in
  let tok : Token := token number-lit num-value (state-line state) (state-column state) (state-position state) in
  (tok, new-state)

-- Tokenize symbol (identifier or keyword)
tokenize-symbol : LexerState ‚Üí (Token √ó LexerState)
tokenize-symbol = Œª(state : LexerState),
  let sym-result : (String √ó LexerState) := consume-while state char-is-symbol-cont in
  let sym-value : String := fst sym-result in
  let new-state : LexerState := snd sym-result in
  let tok-type : TokenType := classify-symbol sym-value in
  let tok : Token := token tok-type sym-value (state-line state) (state-column state) (state-position state) in
  (tok, new-state)

-- Tokenize string literal
tokenize-string : LexerState ‚Üí (Token √ó LexerState)
tokenize-string = Œª(state : LexerState),
  -- Skip opening quote
  let state1 : LexerState := advance-position state in
  let str-result : (String √ó LexerState) := consume-until state1 (char char-code-dquote) in
  let str-value : String := fst str-result in
  let state2 : LexerState := snd str-result in
  -- Skip closing quote
  let new-state : LexerState := advance-position state2 in
  let tok : Token := token string-lit str-value (state-line state) (state-column state) (state-position state) in
  (tok, new-state)

-- Tokenize single character operator
tokenize-single-char : LexerState ‚Üí (Token √ó LexerState)
tokenize-single-char = Œª(state : LexerState),
  let current : Option Char := current-char state in
  option-eliminator current
    -- No character: invalid token
    (let invalid-tok : Token := token invalid empty-string (state-line state) (state-column state) (state-position state) in
     (invalid-tok, state))
    
    -- Classify single character
    (Œª(ch : Char),
      let tok-type : TokenType := classify-single-char ch in
      let tok : Token := token tok-type (char-to-string ch) (state-line state) (state-column state) (state-position state) in
      (tok, advance-position state))

-- ============================================================================
-- CLASSIFICATION FUNCTIONS
-- ============================================================================

-- Classify symbol as keyword or identifier
classify-symbol : String ‚Üí TokenType
classify-symbol = Œª(sym : String),
  bool-eliminator (string-equal sym "lambda")
    lambda-kw
    (bool-eliminator (string-equal sym "Œª")
      lambda-kw
      (bool-eliminator (string-equal sym "let")
        let-kw
        (bool-eliminator (string-equal sym "in")
          in-kw
          (bool-eliminator (string-equal sym "if")
            if-kw
            (bool-eliminator (string-equal sym "then")
              then-kw
              (bool-eliminator (string-equal sym "else")
                else-kw
                (bool-eliminator (string-equal sym "data")
                  data-kw
                  (bool-eliminator (string-equal sym "where")
                    where-kw
                    (bool-eliminator (string-equal sym "import")
                      import-kw
                      (bool-eliminator (string-equal sym "true")
                        bool-lit
                        (bool-eliminator (string-equal sym "false")
                          bool-lit
                          -- Check if identifier starts with uppercase (constructor)
                          (bool-eliminator (string-starts-uppercase sym)
                            constructor-id
                            identifier))))))))))))

-- Classify single character
classify-single-char : Char ‚Üí TokenType
classify-single-char = Œª(ch : Char),
  char-eliminator ch (Œª(codepoint : ‚Ñï),
    bool-eliminator (nat-equal codepoint char-code-lparen)
      lparen
      (bool-eliminator (nat-equal codepoint char-code-rparen)
        rparen
        (bool-eliminator (nat-equal codepoint char-code-lbracket)
          lbracket
          (bool-eliminator (nat-equal codepoint char-code-rbracket)
            rbracket
            (bool-eliminator (nat-equal codepoint char-code-lbrace)
              lbrace
              (bool-eliminator (nat-equal codepoint char-code-rbrace)
                rbrace
                (bool-eliminator (nat-equal codepoint char-code-plus)
                  plus
                  (bool-eliminator (nat-equal codepoint char-code-minus)
                    minus
                    (bool-eliminator (nat-equal codepoint char-code-star)
                      multiply
                      (bool-eliminator (nat-equal codepoint char-code-slash)
                        divide
                        (bool-eliminator (nat-equal codepoint char-code-equal)
                          equal
                          (bool-eliminator (nat-equal codepoint char-code-less)
                            less-than
                            (bool-eliminator (nat-equal codepoint char-code-greater)
                              greater-than
                              invalid)))))))))))))

-- ============================================================================
-- STRING CONSUMPTION HELPERS
-- ============================================================================

-- Consume characters while predicate holds
consume-while : LexerState ‚Üí (Char ‚Üí ùüö) ‚Üí (String √ó LexerState)
consume-while = Œª(state : LexerState), Œª(predicate : Char ‚Üí ùüö),
  consume-while-acc state predicate empty-string

-- Accumulator version of consume-while
consume-while-acc : LexerState ‚Üí (Char ‚Üí ùüö) ‚Üí String ‚Üí (String √ó LexerState)
consume-while-acc = Œª(state : LexerState), Œª(predicate : Char ‚Üí ùüö), Œª(acc : String),
  let current : Option Char := current-char state in
  option-eliminator current
    -- End of input: return accumulated string
    (acc, state)
    
    -- Character available: check predicate
    (Œª(ch : Char),
      bool-eliminator (predicate ch)
        -- Character doesn't match: return accumulated string
        (acc, state)
        -- Character matches: add to accumulator and continue
        (let new-acc : String := string-append acc (char-to-string ch) in
         let new-state : LexerState := advance-position state in
         consume-while-acc new-state predicate new-acc))

-- Consume characters until delimiter found
consume-until : LexerState ‚Üí Char ‚Üí (String √ó LexerState)
consume-until = Œª(state : LexerState), Œª(delimiter : Char),
  consume-until-acc state delimiter empty-string

-- Accumulator version of consume-until
consume-until-acc : LexerState ‚Üí Char ‚Üí String ‚Üí (String √ó LexerState)
consume-until-acc = Œª(state : LexerState), Œª(delimiter : Char), Œª(acc : String),
  let current : Option Char := current-char state in
  option-eliminator current
    -- End of input: return accumulated string
    (acc, state)
    
    -- Character available: check if delimiter
    (Œª(ch : Char),
      bool-eliminator (char-equal ch delimiter)
        -- Found delimiter: return accumulated string
        (acc, state)
        -- Not delimiter: add to accumulator and continue
        (let new-acc : String := string-append acc (char-to-string ch) in
         let new-state : LexerState := advance-position state in
         consume-until-acc new-state delimiter new-acc))

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

-- Convert character to single-character string
char-to-string : Char ‚Üí String
char-to-string = Œª(ch : Char),
  string-cons ch empty-string

-- Check if string starts with uppercase letter
string-starts-uppercase : String ‚Üí ùüö
string-starts-uppercase = Œª(str : String),
  string-eliminator str
    ùüö-false                              -- Empty string: false
    (Œª(first-char : Char), Œª(_ : String), Œª(_ : ùüö),
      char-eliminator first-char (Œª(codepoint : ‚Ñï),
        bool-and
          (nat-greater-equal codepoint char-code-A)
          (nat-less-equal codepoint char-code-Z)))

-- Reverse list of tokens
list-reverse : ‚àÄ(A : ùí∞‚ÇÄ), List A ‚Üí List A
list-reverse = Œª(A : ùí∞‚ÇÄ), Œª(xs : List A),
  list-reverse-acc A xs (nil A)

-- Accumulator version of list reverse
list-reverse-acc : ‚àÄ(A : ùí∞‚ÇÄ), List A ‚Üí List A ‚Üí List A
list-reverse-acc = Œª(A : ùí∞‚ÇÄ), Œª(xs : List A), Œª(acc : List A),
  list-eliminator xs
    acc                                  -- Empty list: return accumulator
    (Œª(head : A), Œª(tail : List A), Œª(_ : List A ‚Üí List A),
      list-reverse-acc A tail (cons head acc))

-- Natural number comparison functions
nat-greater-equal : ‚Ñï ‚Üí ‚Ñï ‚Üí ùüö
nat-greater-equal = Œª(n : ‚Ñï), Œª(m : ‚Ñï),
  bool-or (nat-equal n m) (nat-greater n m)

nat-less-equal : ‚Ñï ‚Üí ‚Ñï ‚Üí ùüö
nat-less-equal = Œª(n : ‚Ñï), Œª(m : ‚Ñï),
  bool-or (nat-equal n m) (nat-less n m)

nat-greater : ‚Ñï ‚Üí ‚Ñï ‚Üí ùüö
nat-greater = Œª(n : ‚Ñï), Œª(m : ‚Ñï),
  nat-less m n

nat-less : ‚Ñï ‚Üí ‚Ñï ‚Üí ùüö
nat-less = Œª(n : ‚Ñï), Œª(m : ‚Ñï),
  nat-eliminator n
    (nat-eliminator m
      ùüö-false                            -- 0 < 0 is false
      (Œª(_ : ‚Ñï), Œª(_ : ùüö), ùüö-true))     -- 0 < succ k is true
    (Œª(pred-n : ‚Ñï), Œª(ih : ‚Ñï ‚Üí ùüö),
      nat-eliminator m
        ùüö-false                          -- succ j < 0 is false
        (Œª(pred-m : ‚Ñï), Œª(_ : ùüö), ih pred-m))  -- succ j < succ k iff j < k

-- Natural number equality
nat-equal : ‚Ñï ‚Üí ‚Ñï ‚Üí ùüö
nat-equal = Œª(n : ‚Ñï), Œª(m : ‚Ñï),
  nat-eliminator n
    (nat-eliminator m
      ùüö-true                             -- 0 = 0 is true
      (Œª(_ : ‚Ñï), Œª(_ : ùüö), ùüö-false))    -- 0 = succ k is false
    (Œª(pred-n : ‚Ñï), Œª(ih : ‚Ñï ‚Üí ùüö),
      nat-eliminator m
        ùüö-false                          -- succ j = 0 is false
        (Œª(pred-m : ‚Ñï), Œª(_ : ùüö), ih pred-m))  -- succ j = succ k iff j = k

-- Character equality
char-equal : Char ‚Üí Char ‚Üí ùüö
char-equal = Œª(c1 : Char), Œª(c2 : Char),
  char-eliminator c1 (Œª(n1 : ‚Ñï),
    char-eliminator c2 (Œª(n2 : ‚Ñï),
      nat-equal n1 n2))

-- Convert natural from decimal digit list
nat-from-decimal : List Digit ‚Üí ‚Ñï
nat-from-decimal = Œª(digits : List Digit),
  list-fold-right Digit ‚Ñï zero
    (Œª(digit : Digit), Œª(acc : ‚Ñï),
      let digit-val : ‚Ñï := digit-to-nat digit in
      let base : ‚Ñï := succ (succ (succ (succ (succ (succ (succ (succ (succ (succ zero))))))))) in
      nat-add digit-val (nat-mult base acc))
    digits

-- Convert digit to natural number
digit-to-nat : Digit ‚Üí ‚Ñï
digit-to-nat = Œª(d : Digit),
  digit-eliminator (Œª(_ : Digit), ‚Ñï)
    zero (succ zero) (succ (succ zero)) (succ (succ (succ zero)))
    (succ (succ (succ (succ zero)))) (succ (succ (succ (succ (succ zero)))))
    (succ (succ (succ (succ (succ (succ zero)))))) (succ (succ (succ (succ (succ (succ (succ zero)))))))
    (succ (succ (succ (succ (succ (succ (succ (succ zero)))))))) (succ (succ (succ (succ (succ (succ (succ (succ (succ zero)))))))))
    d