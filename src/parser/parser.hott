-- ============================================================================
-- PURE HOTT PARSER IMPLEMENTATION
-- ============================================================================
-- Mathematical syntax analysis using only HoTT constructors
-- Recursive descent parsing with formal grammar rules

import effects.effects
import core.operations
import lexer.lexer

-- ============================================================================
-- ABSTRACT SYNTAX TREE (AST) AS INDUCTIVE TYPE
-- ============================================================================

-- Complete AST representation for HoTT language constructs
data AST : ğ’°â‚€ where
  -- Variables and literals
  var-node : String â†’ AST
  literal-node : LiteralValue â†’ AST
  
  -- Function application and abstraction
  app-node : AST â†’ List AST â†’ AST
  lambda-node : List String â†’ AST â†’ AST
  
  -- Let bindings and conditionals
  let-node : List (String Ã— AST) â†’ AST â†’ AST
  if-node : AST â†’ AST â†’ AST â†’ AST
  
  -- Type annotations and declarations
  ann-node : AST â†’ Type â†’ AST
  data-node : String â†’ List (String Ã— Type) â†’ List (String Ã— List Type) â†’ AST
  
  -- HoTT-specific constructs
  pi-node : String â†’ Type â†’ AST â†’ AST
  sigma-node : String â†’ Type â†’ AST â†’ AST
  identity-node : Type â†’ AST â†’ AST â†’ AST
  
  -- Effects and operations
  effect-node : Effect â†’ List AST â†’ AST
  perform-node : String â†’ List AST â†’ AST
  handle-node : AST â†’ List (String Ã— AST) â†’ AST
  
  -- Module system
  import-node : String â†’ AST
  module-node : String â†’ List AST â†’ AST

-- Literal values as separate inductive type
data LiteralValue : ğ’°â‚€ where
  nat-literal : â„• â†’ LiteralValue
  string-literal : String â†’ LiteralValue
  bool-literal : ğŸš â†’ LiteralValue
  char-literal : Char â†’ LiteralValue

-- ============================================================================
-- PARSER STATE AND OPERATIONS
-- ============================================================================

-- Parser state tracking token stream and position
data ParserState : ğ’°â‚€ where
  parser-state :
    (tokens : List Token) â†’
    (position : â„•) â†’
    (errors : List String) â†’
    ParserState

-- Parser state accessors
state-tokens : ParserState â†’ List Token
state-tokens = Î»(state : ParserState),
  match state with
  | parser-state tokens _ _ => tokens

state-position : ParserState â†’ â„•
state-position = Î»(state : ParserState),
  match state with
  | parser-state _ position _ => position

state-errors : ParserState â†’ List String
state-errors = Î»(state : ParserState),
  match state with
  | parser-state _ _ errors => errors

-- Parser operations
current-token : ParserState â†’ Option Token
current-token = Î»(state : ParserState),
  let tokens : List Token := state-tokens state in
  let pos : â„• := state-position state in
  list-nth Token tokens pos (none Token)

advance-parser : ParserState â†’ ParserState
advance-parser = Î»(state : ParserState),
  match state with
  | parser-state tokens position errors =>
    parser-state tokens (succ position) errors

add-error : ParserState â†’ String â†’ ParserState
add-error = Î»(state : ParserState), Î»(error : String),
  match state with
  | parser-state tokens position errors =>
    parser-state tokens position (cons error errors)

at-end : ParserState â†’ ğŸš
at-end = Î»(state : ParserState),
  let current : Option Token := current-token state in
  option-eliminator current
    ğŸš-true                               -- No current token: at end
    (Î»(token : Token),
      token-type-equal (token-type token) eof)

-- ============================================================================
-- PARSING RESULT TYPE
-- ============================================================================

-- Parsing result with success/failure information
data ParseResult (A : ğ’°â‚€) : ğ’°â‚€ where
  parse-success : A â†’ ParserState â†’ ParseResult A
  parse-failure : String â†’ ParserState â†’ ParseResult A

-- ParseResult operations
is-success : âˆ€(A : ğ’°â‚€), ParseResult A â†’ ğŸš
is-success = Î»(A : ğ’°â‚€), Î»(result : ParseResult A),
  match result with
  | parse-success _ _ => ğŸš-true
  | parse-failure _ _ => ğŸš-false

extract-success : âˆ€(A : ğ’°â‚€), ParseResult A â†’ Option (A Ã— ParserState)
extract-success = Î»(A : ğ’°â‚€), Î»(result : ParseResult A),
  match result with
  | parse-success value state => some (value, state)
  | parse-failure _ _ => none (A Ã— ParserState)

extract-error : âˆ€(A : ğ’°â‚€), ParseResult A â†’ Option String
extract-error = Î»(A : ğ’°â‚€), Î»(result : ParseResult A),
  match result with
  | parse-success _ _ => none String
  | parse-failure error _ => some error

-- ============================================================================
-- MAIN PARSING FUNCTION
-- ============================================================================

-- Parse complete program from token list
parse : List Token â†’ ParseResult (List AST)
parse = Î»(tokens : List Token),
  let initial-state : ParserState := parser-state tokens zero (nil String) in
  parse-program initial-state

-- Parse program (sequence of declarations)
parse-program : ParserState â†’ ParseResult (List AST)
parse-program = Î»(state : ParserState),
  parse-declarations state (nil AST)

-- Parse declarations accumulator
parse-declarations : ParserState â†’ List AST â†’ ParseResult (List AST)
parse-declarations = Î»(state : ParserState), Î»(acc : List AST),
  bool-eliminator (at-end state)
    -- At end: return accumulated declarations
    (parse-success (list-reverse AST acc) state)
    
    -- Not at end: parse next declaration
    (let decl-result : ParseResult AST := parse-declaration state in
     match decl-result with
     | parse-success decl new-state =>
       parse-declarations new-state (cons decl acc)
     | parse-failure error error-state =>
       parse-failure error error-state)

-- ============================================================================
-- DECLARATION PARSING
-- ============================================================================

-- Parse top-level declaration
parse-declaration : ParserState â†’ ParseResult AST
parse-declaration = Î»(state : ParserState),
  let state1 : ParserState := skip-whitespace state in
  let current : Option Token := current-token state1 in
  option-eliminator current
    -- No token: unexpected end
    (parse-failure "Unexpected end of input" state1)
    
    -- Token available: classify and parse
    (Î»(token : Token),
      token-type-eliminator (token-type token)
        -- Data declaration
        (bool-eliminator (token-type-equal (token-type token) data-kw)
          (parse-data-declaration state1)
          
          -- Import declaration
          (bool-eliminator (token-type-equal (token-type token) import-kw)
            (parse-import-declaration state1)
            
            -- Function definition or expression
            (parse-expression state1)))

-- Parse data type declaration
parse-data-declaration : ParserState â†’ ParseResult AST
parse-data-declaration = Î»(state : ParserState),
  -- Expect 'data' keyword
  let state1 : ParserState := expect-token state data-kw in
  -- Parse type name
  let name-result : ParseResult String := parse-identifier state1 in
  match name-result with
  | parse-failure error error-state => parse-failure error error-state
  | parse-success type-name state2 =>
    -- Parse type parameters
    let params-result : ParseResult (List (String Ã— Type)) := parse-type-parameters state2 in
    match params-result with
    | parse-failure error error-state => parse-failure error error-state
    | parse-success params state3 =>
      -- Expect 'where' keyword
      let state4 : ParserState := expect-token state3 where-kw in
      -- Parse constructors
      let constrs-result : ParseResult (List (String Ã— List Type)) := parse-constructors state4 in
      match constrs-result with
      | parse-failure error error-state => parse-failure error error-state
      | parse-success constructors state5 =>
        let data-ast : AST := data-node type-name params constructors in
        parse-success data-ast state5

-- Parse import declaration
parse-import-declaration : ParserState â†’ ParseResult AST
parse-import-declaration = Î»(state : ParserState),
  -- Expect 'import' keyword
  let state1 : ParserState := expect-token state import-kw in
  -- Parse module name
  let name-result : ParseResult String := parse-identifier state1 in
  match name-result with
  | parse-failure error error-state => parse-failure error error-state
  | parse-success module-name state2 =>
    let import-ast : AST := import-node module-name in
    parse-success import-ast state2

-- ============================================================================
-- EXPRESSION PARSING (RECURSIVE DESCENT)
-- ============================================================================

-- Parse expression with precedence handling
parse-expression : ParserState â†’ ParseResult AST
parse-expression = Î»(state : ParserState),
  parse-lambda-or-application state

-- Parse lambda expression or function application
parse-lambda-or-application : ParserState â†’ ParseResult AST
parse-lambda-or-application = Î»(state : ParserState),
  let state1 : ParserState := skip-whitespace state in
  let current : Option Token := current-token state1 in
  option-eliminator current
    (parse-failure "Expected expression" state1)
    
    (Î»(token : Token),
      -- Check for lambda keyword
      bool-eliminator (token-type-equal (token-type token) lambda-kw)
        (parse-lambda state1)
        
        -- Check for let keyword
        (bool-eliminator (token-type-equal (token-type token) let-kw)
          (parse-let state1)
          
          -- Check for if keyword
          (bool-eliminator (token-type-equal (token-type token) if-kw)
            (parse-if state1)
            
            -- Otherwise parse application
            (parse-application state1))))

-- Parse lambda expression
parse-lambda : ParserState â†’ ParseResult AST
parse-lambda = Î»(state : ParserState),
  -- Expect lambda keyword
  let state1 : ParserState := expect-token state lambda-kw in
  -- Parse parameter list
  let params-result : ParseResult (List String) := parse-parameter-list state1 in
  match params-result with
  | parse-failure error error-state => parse-failure error error-state
  | parse-success params state2 =>
    -- Expect arrow or dot
    let state3 : ParserState := expect-token state2 arrow in
    -- Parse body
    let body-result : ParseResult AST := parse-expression state3 in
    match body-result with
    | parse-failure error error-state => parse-failure error error-state
    | parse-success body state4 =>
      let lambda-ast : AST := lambda-node params body in
      parse-success lambda-ast state4

-- Parse let expression
parse-let : ParserState â†’ ParseResult AST
parse-let = Î»(state : ParserState),
  -- Expect 'let' keyword
  let state1 : ParserState := expect-token state let-kw in
  -- Parse bindings
  let bindings-result : ParseResult (List (String Ã— AST)) := parse-let-bindings state1 in
  match bindings-result with
  | parse-failure error error-state => parse-failure error error-state
  | parse-success bindings state2 =>
    -- Expect 'in' keyword
    let state3 : ParserState := expect-token state2 in-kw in
    -- Parse body
    let body-result : ParseResult AST := parse-expression state3 in
    match body-result with
    | parse-failure error error-state => parse-failure error error-state
    | parse-success body state4 =>
      let let-ast : AST := let-node bindings body in
      parse-success let-ast state4

-- Parse if expression
parse-if : ParserState â†’ ParseResult AST
parse-if = Î»(state : ParserState),
  -- Expect 'if' keyword
  let state1 : ParserState := expect-token state if-kw in
  -- Parse condition
  let cond-result : ParseResult AST := parse-expression state1 in
  match cond-result with
  | parse-failure error error-state => parse-failure error error-state
  | parse-success condition state2 =>
    -- Expect 'then' keyword
    let state3 : ParserState := expect-token state2 then-kw in
    -- Parse then branch
    let then-result : ParseResult AST := parse-expression state3 in
    match then-result with
    | parse-failure error error-state => parse-failure error error-state
    | parse-success then-branch state4 =>
      -- Expect 'else' keyword
      let state5 : ParserState := expect-token state4 else-kw in
      -- Parse else branch
      let else-result : ParseResult AST := parse-expression state5 in
      match else-result with
      | parse-failure error error-state => parse-failure error error-state
      | parse-success else-branch state6 =>
        let if-ast : AST := if-node condition then-branch else-branch in
        parse-success if-ast state6

-- Parse function application
parse-application : ParserState â†’ ParseResult AST
parse-application = Î»(state : ParserState),
  -- Parse function (atomic expression)
  let func-result : ParseResult AST := parse-atomic state in
  match func-result with
  | parse-failure error error-state => parse-failure error error-state
  | parse-success func state1 =>
    -- Parse argument list
    let args-result : ParseResult (List AST) := parse-argument-list state1 in
    match args-result with
    | parse-failure error error-state => parse-failure error error-state
    | parse-success args state2 =>
      -- Create application node
      let app-ast : AST := 
        bool-eliminator (list-is-empty AST args)
          func                           -- No arguments: return function
          (app-node func args) in        -- Has arguments: create application
      parse-success app-ast state2

-- ============================================================================
-- ATOMIC EXPRESSION PARSING
-- ============================================================================

-- Parse atomic expressions (variables, literals, parenthesized expressions)
parse-atomic : ParserState â†’ ParseResult AST
parse-atomic = Î»(state : ParserState),
  let state1 : ParserState := skip-whitespace state in
  let current : Option Token := current-token state1 in
  option-eliminator current
    (parse-failure "Expected atomic expression" state1)
    
    (Î»(token : Token),
      -- Variable or constructor
      bool-eliminator (token-type-equal (token-type token) identifier)
        (parse-variable state1)
        
        (bool-eliminator (token-type-equal (token-type token) constructor-id)
          (parse-variable state1)
          
          -- Number literal
          (bool-eliminator (token-type-equal (token-type token) number-lit)
            (parse-number-literal state1)
            
            -- String literal
            (bool-eliminator (token-type-equal (token-type token) string-lit)
              (parse-string-literal state1)
              
              -- Boolean literal
              (bool-eliminator (token-type-equal (token-type token) bool-lit)
                (parse-bool-literal state1)
                
                -- Parenthesized expression
                (bool-eliminator (token-type-equal (token-type token) lparen)
                  (parse-parenthesized state1)
                  
                  (parse-failure "Unexpected token in atomic expression" state1)))))))

-- Parse variable reference
parse-variable : ParserState â†’ ParseResult AST
parse-variable = Î»(state : ParserState),
  let current : Option Token := current-token state in
  option-eliminator current
    (parse-failure "Expected identifier" state)
    
    (Î»(token : Token),
      let name : String := token-value token in
      let var-ast : AST := var-node name in
      let new-state : ParserState := advance-parser state in
      parse-success var-ast new-state)

-- Parse number literal
parse-number-literal : ParserState â†’ ParseResult AST
parse-number-literal = Î»(state : ParserState),
  let current : Option Token := current-token state in
  option-eliminator current
    (parse-failure "Expected number" state)
    
    (Î»(token : Token),
      let value-str : String := token-value token in
      let value : â„• := string-to-nat value-str in
      let lit : LiteralValue := nat-literal value in
      let lit-ast : AST := literal-node lit in
      let new-state : ParserState := advance-parser state in
      parse-success lit-ast new-state)

-- Parse string literal
parse-string-literal : ParserState â†’ ParseResult AST
parse-string-literal = Î»(state : ParserState),
  let current : Option Token := current-token state in
  option-eliminator current
    (parse-failure "Expected string" state)
    
    (Î»(token : Token),
      let value : String := token-value token in
      let lit : LiteralValue := string-literal value in
      let lit-ast : AST := literal-node lit in
      let new-state : ParserState := advance-parser state in
      parse-success lit-ast new-state)

-- Parse boolean literal
parse-bool-literal : ParserState â†’ ParseResult AST
parse-bool-literal = Î»(state : ParserState),
  let current : Option Token := current-token state in
  option-eliminator current
    (parse-failure "Expected boolean" state)
    
    (Î»(token : Token),
      let value-str : String := token-value token in
      let value : ğŸš := string-to-bool value-str in
      let lit : LiteralValue := bool-literal value in
      let lit-ast : AST := literal-node lit in
      let new-state : ParserState := advance-parser state in
      parse-success lit-ast new-state)

-- Parse parenthesized expression
parse-parenthesized : ParserState â†’ ParseResult AST
parse-parenthesized = Î»(state : ParserState),
  -- Expect opening parenthesis
  let state1 : ParserState := expect-token state lparen in
  -- Parse inner expression
  let expr-result : ParseResult AST := parse-expression state1 in
  match expr-result with
  | parse-failure error error-state => parse-failure error error-state
  | parse-success expr state2 =>
    -- Expect closing parenthesis
    let state3 : ParserState := expect-token state2 rparen in
    parse-success expr state3

-- ============================================================================
-- HELPER PARSING FUNCTIONS
-- ============================================================================

-- Parse identifier and return string
parse-identifier : ParserState â†’ ParseResult String
parse-identifier = Î»(state : ParserState),
  let current : Option Token := current-token state in
  option-eliminator current
    (parse-failure "Expected identifier" state)
    
    (Î»(token : Token),
      bool-eliminator (token-type-equal (token-type token) identifier)
        (let name : String := token-value token in
         let new-state : ParserState := advance-parser state in
         parse-success name new-state)
        (parse-failure "Expected identifier" state))

-- Parse parameter list for lambda
parse-parameter-list : ParserState â†’ ParseResult (List String)
parse-parameter-list = Î»(state : ParserState),
  parse-parameter-list-acc state (nil String)

-- Accumulator version of parameter list parsing
parse-parameter-list-acc : ParserState â†’ List String â†’ ParseResult (List String)
parse-parameter-list-acc = Î»(state : ParserState), Î»(acc : List String),
  let state1 : ParserState := skip-whitespace state in
  let current : Option Token := current-token state1 in
  option-eliminator current
    (parse-success (list-reverse String acc) state1)
    
    (Î»(token : Token),
      -- Check if next token is arrow (end of parameters)
      bool-eliminator (token-type-equal (token-type token) arrow)
        (parse-success (list-reverse String acc) state1)
        
        -- Otherwise try to parse identifier
        (bool-eliminator (token-type-equal (token-type token) identifier)
          (let name : String := token-value token in
           let new-state : ParserState := advance-parser state1 in
           parse-parameter-list-acc new-state (cons name acc))
          
          (parse-success (list-reverse String acc) state1)))

-- Parse argument list for application
parse-argument-list : ParserState â†’ ParseResult (List AST)
parse-argument-list = Î»(state : ParserState),
  parse-argument-list-acc state (nil AST)

-- Accumulator version of argument list parsing
parse-argument-list-acc : ParserState â†’ List AST â†’ ParseResult (List AST)
parse-argument-list-acc = Î»(state : ParserState), Î»(acc : List AST),
  let state1 : ParserState := skip-whitespace state in
  -- Try to parse atomic expression
  let arg-result : ParseResult AST := parse-atomic state1 in
  match arg-result with
  | parse-failure _ _ =>
    -- No more arguments: return accumulated list
    parse-success (list-reverse AST acc) state1
  | parse-success arg state2 =>
    -- Found argument: continue parsing
    parse-argument-list-acc state2 (cons arg acc)

-- ============================================================================
-- UTILITY PARSING FUNCTIONS
-- ============================================================================

-- Skip whitespace tokens
skip-whitespace : ParserState â†’ ParserState
skip-whitespace = Î»(state : ParserState),
  let current : Option Token := current-token state in
  option-eliminator current
    state                                -- No token: return state
    
    (Î»(token : Token),
      bool-eliminator (token-type-equal (token-type token) whitespace)
        (skip-whitespace (advance-parser state))  -- Whitespace: skip and continue
        state)                           -- Not whitespace: return state

-- Expect specific token type
expect-token : ParserState â†’ TokenType â†’ ParserState
expect-token = Î»(state : ParserState), Î»(expected : TokenType),
  let state1 : ParserState := skip-whitespace state in
  let current : Option Token := current-token state1 in
  option-eliminator current
    -- No token: error but continue
    state1
    
    (Î»(token : Token),
      bool-eliminator (token-type-equal (token-type token) expected)
        (advance-parser state1)          -- Expected token: consume and advance
        state1)                          -- Wrong token: error but continue

-- Token type equality
token-type-equal : TokenType â†’ TokenType â†’ ğŸš
token-type-equal = Î»(t1 : TokenType), Î»(t2 : TokenType),
  -- This would be a large case analysis over all token type constructors
  -- For now, simplified to structural equality placeholder
  ğŸš-true  -- Placeholder implementation

-- ============================================================================
-- CONVERSION FUNCTIONS
-- ============================================================================

-- Convert string to natural number
string-to-nat : String â†’ â„•
string-to-nat = Î»(str : String),
  -- Parse decimal digits from string
  string-eliminator str
    zero                                 -- Empty string: 0
    (Î»(ch : Char), Î»(rest : String), Î»(ih : â„•),
      let digit-val : â„• := char-to-digit ch in
      let rest-val : â„• := ih in
      let base : â„• := succ (succ (succ (succ (succ (succ (succ (succ (succ (succ zero))))))))) in
      nat-add (nat-mult rest-val base) digit-val)

-- Convert character to digit value
char-to-digit : Char â†’ â„•
char-to-digit = Î»(ch : Char),
  char-eliminator ch (Î»(codepoint : â„•),
    bool-eliminator (bool-and 
                      (nat-greater-equal codepoint (char-code-0))
                      (nat-less-equal codepoint (char-code-9)))
      (nat-subtract codepoint (char-code-0))
      zero)

-- Convert string to boolean
string-to-bool : String â†’ ğŸš
string-to-bool = Î»(str : String),
  bool-eliminator (string-equal str "true")
    ğŸš-true
    (bool-eliminator (string-equal str "false")
      ğŸš-false
      ğŸš-false)                          -- Default to false

-- List operations
list-is-empty : âˆ€(A : ğ’°â‚€), List A â†’ ğŸš
list-is-empty = Î»(A : ğ’°â‚€), Î»(xs : List A),
  list-eliminator xs
    ğŸš-true                               -- Empty list
    (Î»(_ : A), Î»(_ : List A), Î»(_ : ğŸš), ğŸš-false)  -- Non-empty list

list-reverse : âˆ€(A : ğ’°â‚€), List A â†’ List A
list-reverse = Î»(A : ğ’°â‚€), Î»(xs : List A),
  list-reverse-acc A xs (nil A)

list-reverse-acc : âˆ€(A : ğ’°â‚€), List A â†’ List A â†’ List A
list-reverse-acc = Î»(A : ğ’°â‚€), Î»(xs : List A), Î»(acc : List A),
  list-eliminator xs
    acc                                  -- Empty: return accumulator
    (Î»(head : A), Î»(tail : List A), Î»(_ : List A â†’ List A),
      list-reverse-acc A tail (cons head acc))

-- Natural number arithmetic
nat-add : â„• â†’ â„• â†’ â„•
nat-add = Î»(n : â„•), Î»(m : â„•),
  nat-eliminator n
    m                                    -- 0 + m = m
    (Î»(pred : â„•), Î»(ih : â„•), succ ih)   -- (succ k) + m = succ (k + m)

nat-mult : â„• â†’ â„• â†’ â„•
nat-mult = Î»(n : â„•), Î»(m : â„•),
  nat-eliminator n
    zero                                 -- 0 * m = 0
    (Î»(pred : â„•), Î»(ih : â„•), nat-add m ih)  -- (succ k) * m = m + (k * m)

nat-subtract : â„• â†’ â„• â†’ â„•
nat-subtract = Î»(n : â„•), Î»(m : â„•),
  nat-eliminator m
    n                                    -- n - 0 = n
    (Î»(pred : â„•), Î»(ih : â„•), nat-pred ih)  -- n - (succ k) = pred(n - k)

nat-pred : â„• â†’ â„•
nat-pred = Î»(n : â„•),
  nat-eliminator n
    zero                                 -- pred(0) = 0
    (Î»(pred : â„•), Î»(_ : â„•), pred)       -- pred(succ k) = k

-- Natural number comparisons (from lexer)
nat-greater-equal : â„• â†’ â„• â†’ ğŸš
nat-greater-equal = Î»(n : â„•), Î»(m : â„•),
  bool-or (nat-equal n m) (nat-greater n m)

nat-less-equal : â„• â†’ â„• â†’ ğŸš  
nat-less-equal = Î»(n : â„•), Î»(m : â„•),
  bool-or (nat-equal n m) (nat-less n m)

nat-greater : â„• â†’ â„• â†’ ğŸš
nat-greater = Î»(n : â„•), Î»(m : â„•),
  nat-less m n

nat-less : â„• â†’ â„• â†’ ğŸš
nat-less = Î»(n : â„•), Î»(m : â„•),
  nat-eliminator n
    (nat-eliminator m
      ğŸš-false                            -- 0 < 0 is false
      (Î»(_ : â„•), Î»(_ : ğŸš), ğŸš-true))     -- 0 < succ k is true
    (Î»(pred-n : â„•), Î»(ih : â„• â†’ ğŸš),
      nat-eliminator m
        ğŸš-false                          -- succ j < 0 is false
        (Î»(pred-m : â„•), Î»(_ : ğŸš), ih pred-m))  -- succ j < succ k iff j < k

nat-equal : â„• â†’ â„• â†’ ğŸš
nat-equal = Î»(n : â„•), Î»(m : â„•),
  nat-eliminator n
    (nat-eliminator m
      ğŸš-true                             -- 0 = 0 is true
      (Î»(_ : â„•), Î»(_ : ğŸš), ğŸš-false))    -- 0 = succ k is false
    (Î»(pred-n : â„•), Î»(ih : â„• â†’ ğŸš),
      nat-eliminator m
        ğŸš-false                          -- succ j = 0 is false
        (Î»(pred-m : â„•), Î»(_ : ğŸš), ih pred-m))  -- succ j = succ k iff j = k