#lang racket/base

(require racket/contract
         racket/match
         racket/list
         "../types/types.rkt"
         "../evaluator/values.rkt"
         (prefix-in hott-cache: "../core/hott-cache.rkt")
         (prefix-in pure-effects: "pure-hott-effects.rkt")
         "../core/primitive-effects.rkt"
         "../core/host-bridge.rkt")

(provide execute-effect-description
         execute-effect-with-cache
         effect-execution-context
         make-effect-execution-context
         cached-effect-executor
         effect-result
         effect-result?
         effect-result-value
         effect-result-cache
         effect-result-evidence
         effect-result-timestamp
         compose-effect-results
         effect-executor-registry
         register-effect-executor!
         ;; Tier-aware execution contexts
         make-tier0-context
         make-tier1-context
         make-tier2-context
         make-tier3-context)

;; ============================================================================
;; EFFECT EXECUTION CONTEXT
;; ============================================================================
;; Execution context carries cache, execution mode, and environment

(struct effect-execution-context (cache execution-mode environment timestamp) #:transparent)

;; Create execution context with tier-aware mode
(define/contract (make-effect-execution-context cache [mode 'tier3] [env #f])
  (->* (constructor-value?) (symbol? (or/c hash? #f)) effect-execution-context?)
  (effect-execution-context cache mode env (current-seconds)))

;; Convenience functions for tier-specific contexts
(define/contract (make-tier0-context cache)
  (-> constructor-value? effect-execution-context?)
  (make-effect-execution-context cache 'tier0))

(define/contract (make-tier1-context cache)
  (-> constructor-value? effect-execution-context?)
  (make-effect-execution-context cache 'tier1))

(define/contract (make-tier2-context cache)
  (-> constructor-value? effect-execution-context?)
  (make-effect-execution-context cache 'tier2))

(define/contract (make-tier3-context cache)
  (-> constructor-value? effect-execution-context?)
  (make-effect-execution-context cache 'tier3))

;; ============================================================================
;; EFFECT EXECUTION RESULTS
;; ============================================================================
;; Effect execution returns value + computational evidence

(struct effect-result (value evidence timestamp cache) #:transparent)

;; effect-result? is automatically generated by the struct definition

;; Extract functions are automatically generated by the struct definition:
;; effect-result-value, effect-result-evidence, effect-result-timestamp, effect-result-cache

;; Compose multiple effect results
(define/contract (compose-effect-results . results)
  (->* () () #:rest (listof effect-result?) effect-result?)
  (if (null? results)
      (effect-result unit unit (current-seconds) (hott-cache:make-empty-cache))
      (let* ([final-result (last results)]
             [all-values (map effect-result-value results)]
             [all-evidence (map effect-result-evidence results)]
             [final-cache (effect-result-cache final-result)])
        (effect-result 
          (racket-list->hott-list all-values)
          (racket-list->hott-list all-evidence)
          (current-seconds)
          final-cache))))

;; ============================================================================
;; EFFECT EXECUTOR REGISTRY
;; ============================================================================
;; Custom effect executors for complex effect types

(define effect-executor-registry (make-hash))

;; Register custom effect executor
(define/contract (register-effect-executor! effect-name executor)
  (-> string? procedure? void?)
  (hash-set! effect-executor-registry effect-name executor))

;; ============================================================================
;; CORE EFFECT EXECUTION ENGINE
;; ============================================================================

;; Execute effect description with full caching support
(define/contract (execute-effect-with-cache effect-desc context)
  (-> constructor-value? effect-execution-context? effect-result?)
  (let ([cache (effect-execution-context-cache context)]
        [mode (effect-execution-context-execution-mode context)])
    
    ;; Tier-aware effect execution with caching
    (cond
      ;; Tier 0: Compile-time elimination (pure effects become constants)
      [(eq? mode 'tier0)
       (tier0-execute-effect effect-desc context)]
      
      ;; Tier 1: Compile-time specialization with aggressive caching
      [(eq? mode 'tier1)
       (tier1-execute-effect effect-desc context)]
      
      ;; Tier 2: Mixed compile-time/runtime with effect promotion
      [(eq? mode 'tier2)
       (tier2-execute-effect effect-desc context)]
      
      ;; Tier 3: Runtime execution with content-addressable caching
      [(eq? mode 'tier3)
       (tier3-execute-effect effect-desc context)]
      
      ;; Legacy runtime mode maps to tier3
      [(eq? mode 'runtime)
       (tier3-execute-effect effect-desc context)]
      
      [else (error "Unknown execution mode: " mode)])))

;; ============================================================================
;; TIER-AWARE EFFECT EXECUTION IMPLEMENTATIONS
;; ============================================================================

;; Tier 0: Compile-time elimination (pure effects become constants)
(define/contract (tier0-execute-effect effect-desc context)
  (-> constructor-value? effect-execution-context? effect-result?)
  (match effect-desc
    ;; Pure effects are already constants - eliminate at compile time
    [(constructor-value "pure-effect" (list value) _)
     (effect-result value
                    (constructor-value "compile-time-eliminated" (list effect-desc)
                                     (inductive-type "Tier0Evidence" '()))
                    (current-seconds)
                    (effect-execution-context-cache context))]
    
    ;; Deterministic I/O effects can be pre-computed if inputs are known
    [(constructor-value "io-effect" (list name-val op-val args-val det-val) _)
     (if (pure-effects:effect-deterministic? effect-desc)
         ;; Try to resolve at compile time
         (tier1-execute-effect effect-desc context)
         ;; Fall back to tier3 for non-deterministic effects
         (tier3-execute-effect effect-desc context))]
    
    ;; Composed effects - try to eliminate components
    [_ (tier1-execute-effect effect-desc context)]))

;; Tier 1: Compile-time specialization with aggressive caching  
(define/contract (tier1-execute-effect effect-desc context)
  (-> constructor-value? effect-execution-context? effect-result?)
  (let ([cache (effect-execution-context-cache context)])
    ;; Always cache deterministic effects aggressively at tier1
    (if (pure-effects:effect-deterministic? effect-desc)
        (let ([cache-key (pure-effects:effect-cache-key effect-desc)])
          (match (hott-cache:hott-cache-lookup cache-key cache)
            [(constructor-value "some" (list cached-value) _)
             ;; Cache hit - specialized execution 
             (effect-result cached-value
                           (constructor-value "tier1-cached" (list cache-key)
                                            (inductive-type "Tier1Evidence" '()))
                           (current-seconds)
                           cache)]
            [_
             ;; Cache miss - execute and cache with specialization
             (let ([result (execute-effect-description effect-desc context)])
               (let ([new-cache (hott-cache:hott-cache-insert cache-key 
                                                  (effect-result-value result)
                                                  cache)])
                 (effect-result (effect-result-value result)
                               (constructor-value "tier1-specialized"
                                                 (list effect-desc (effect-result-evidence result))
                                                 (inductive-type "Tier1Evidence" '()))
                               (current-seconds)
                               new-cache)))]))
        ;; Non-deterministic - execute directly
        (execute-effect-description effect-desc context))))

;; Tier 2: Mixed compile-time/runtime with effect promotion
(define/contract (tier2-execute-effect effect-desc context)
  (-> constructor-value? effect-execution-context? effect-result?)
  ;; Tier 2 promotes frequently used effects to tier1
  (let ([result (tier1-execute-effect effect-desc context)])
    (effect-result (effect-result-value result)
                  (constructor-value "tier2-promoted"
                                   (list (effect-result-evidence result))
                                   (inductive-type "Tier2Evidence" '()))
                  (current-seconds)
                  (effect-result-cache result))))

;; Tier 3: Runtime execution with content-addressable caching
(define/contract (tier3-execute-effect effect-desc context)
  (-> constructor-value? effect-execution-context? effect-result?)
  (let ([cache (effect-execution-context-cache context)])
    ;; Standard runtime caching for deterministic effects
    (if (pure-effects:effect-deterministic? effect-desc)
        ;; Deterministic - use caching
        (let ([cache-key (pure-effects:effect-cache-key effect-desc)])
          (match (hott-cache:hott-cache-lookup cache-key cache)
            [(constructor-value "some" (list cached-value) _)
             ;; Cache hit - runtime cached result
             (effect-result cached-value
                           (constructor-value "tier3-cached" (list cache-key)
                                            (inductive-type "Tier3Evidence" '()))
                           (current-seconds)
                           cache)]
            [_
             ;; Cache miss - execute and cache
             (let* ([result (execute-effect-description effect-desc context)]
                    [new-cache (hott-cache:hott-cache-insert cache-key 
                                                   (effect-result-value result)
                                                   cache)])
               (effect-result (effect-result-value result)
                             (constructor-value "tier3-computed"
                                               (list effect-desc (effect-result-evidence result))
                                               (inductive-type "Tier3Evidence" '()))
                             (current-seconds)
                             new-cache))]))
        ;; Non-deterministic - execute directly  
        (execute-effect-description effect-desc context))))

;; Execute effect description without caching
(define/contract (execute-effect-description effect-desc context)
  (-> constructor-value? effect-execution-context? effect-result?)
  (match effect-desc
    ;; Pure effect - return value immediately
    [(constructor-value "pure-effect" (list value) _)
     (effect-result value
                    (constructor-value "pure-evidence" (list value)
                                     (inductive-type "PureEvidence" '()))
                    (current-seconds)
                    (effect-execution-context-cache context))]
    
    ;; I/O effect - delegate to primitive implementation
    [(constructor-value "io-effect" (list name-val op-val args-val det-val) _)
     (let ([effect-name (string-value-content name-val)]
           [operation (string-value-content op-val)]
           [args (hott-list->racket-list args-val)])
       (execute-io-effect effect-name operation args context))]
    
    ;; Sequential composition
    [(constructor-value "effect-seq" (list first-effect second-effect) _)
     (let* ([first-result (execute-effect-with-cache first-effect context)]
            [new-context (struct-copy effect-execution-context context
                                     [cache (effect-result-cache first-result)])]
            [second-result (execute-effect-with-cache second-effect new-context)])
       (effect-result (effect-result-value second-result)
                     (constructor-value "seq-evidence" 
                                       (list (effect-result-evidence first-result)
                                             (effect-result-evidence second-result))
                                       (inductive-type "SeqEvidence" '()))
                     (current-seconds)
                     (effect-result-cache second-result)))]
    
    ;; Parallel composition (simplified - execute sequentially for now)
    [(constructor-value "effect-par" (list first-effect second-effect) _)
     (let* ([first-result (execute-effect-with-cache first-effect context)]
            [second-result (execute-effect-with-cache second-effect context)]
            [combined-cache (hott-cache:hott-cache-union (effect-result-cache first-result)
                                             (effect-result-cache second-result))])
       (effect-result (constructor-value "pair"
                                        (list (effect-result-value first-result)
                                              (effect-result-value second-result))
                                        (inductive-type "Pair" '()))
                     (constructor-value "par-evidence"
                                       (list (effect-result-evidence first-result)
                                             (effect-result-evidence second-result))
                                       (inductive-type "ParEvidence" '()))
                     (current-seconds)
                     combined-cache))]
    
    ;; Choice composition (execute first alternative for now)
    [(constructor-value "effect-choice" (list first-effect second-effect) _)
     (let ([result (execute-effect-with-cache first-effect context)])
       (effect-result (effect-result-value result)
                     (constructor-value "choice-evidence"
                                       (list (constructor-value "first" '() 
                                                              (inductive-type "Choice" '()))
                                             (effect-result-evidence result))
                                       (inductive-type "ChoiceEvidence" '()))
                     (current-seconds)
                     (effect-result-cache result)))]
    
    ;; Custom effect - check registry
    [_
     (let ([effect-name (constructor-value-constructor-name effect-desc)])
       (let ([custom-executor (hash-ref effect-executor-registry effect-name #f)])
         (if custom-executor
             (custom-executor effect-desc context)
             (error "Unknown effect type: " effect-name))))]))

;; ============================================================================
;; I/O EFFECT EXECUTION
;; ============================================================================

;; Execute I/O effect using primitive implementation
(define/contract (execute-io-effect effect-name operation args context)
  (-> string? string? (listof constructor-value?) effect-execution-context? effect-result?)
  (if (primitive-effect? effect-name operation)
      ;; Execute primitive effect
      (let* ([start-time (current-inexact-milliseconds)]
             [result-value (execute-primitive-effect effect-name operation args)]
             [end-time (current-inexact-milliseconds)]
             [duration (- end-time start-time)])
        (effect-result result-value
                      (constructor-value "io-evidence"
                                        (list (string-value effect-name)
                                              (string-value operation)
                                              (racket-list->hott-list args)
                                              (racket-number->hott-nat (inexact->exact (floor duration))))
                                        (inductive-type "IOEvidence" '()))
                      (current-seconds)
                      (effect-execution-context-cache context)))
      ;; Custom I/O effect - check for user-defined implementation
      (error "I/O effect not implemented: " effect-name "." operation)))

;; ============================================================================
;; CACHED EFFECT EXECUTOR
;; ============================================================================

;; High-level cached effect executor
(define/contract (cached-effect-executor effect-desc cache)
  (-> constructor-value? constructor-value? effect-result?)
  (let ([context (make-effect-execution-context cache 'runtime)])
    (execute-effect-with-cache effect-desc context)))

;; ============================================================================
;; EFFECT COMPOSITION EXECUTION
;; ============================================================================

;; Execute multiple effects in sequence
(define/contract (execute-effects-sequence effects cache)
  (-> (listof constructor-value?) constructor-value? effect-result?)
  (if (null? effects)
      (effect-result unit 
                    (constructor-value "empty-sequence" '() (inductive-type "EmptyEvidence" '()))
                    (current-seconds)
                    cache)
      (let ([composed-effect (apply pure-effects:compose-effects effects)])
        (cached-effect-executor composed-effect cache))))

;; Execute multiple effects in parallel (simplified)
(define/contract (execute-effects-parallel effects cache)
  (-> (listof constructor-value?) constructor-value? effect-result?)
  (if (null? effects)
      (effect-result unit
                    (constructor-value "empty-parallel" '() (inductive-type "EmptyEvidence" '()))
                    (current-seconds)
                    cache)
      (let* ([results (map (lambda (effect) 
                            (cached-effect-executor effect cache)) 
                          effects)]
             [final-cache (foldl hott-cache:hott-cache-union cache 
                                (map effect-result-cache results))])
        (effect-result (racket-list->hott-list (map effect-result-value results))
                      (racket-list->hott-list (map effect-result-evidence results))
                      (current-seconds)
                      final-cache))))

;; ============================================================================
;; HELPER FUNCTIONS
;; ============================================================================

;; Convert Racket list to HoTT list (duplicate from pure-hott-effects for self-containment)
(define/contract (racket-list->hott-list racket-list)
  (-> (listof constructor-value?) constructor-value?)
  (if (null? racket-list)
      (constructor-value "nil" '() (inductive-type "List" '()))
      (constructor-value "cons" 
                        (list (first racket-list)
                              (racket-list->hott-list (rest racket-list)))
                        (inductive-type "List" '()))))

;; Convert HoTT list to Racket list
(define/contract (hott-list->racket-list hott-list)
  (-> constructor-value? (listof constructor-value?))
  (match hott-list
    [(constructor-value "nil" _ _) '()]
    [(constructor-value "cons" (list head tail) _)
     (cons head (hott-list->racket-list tail))]
    [_ '()]))

;; ============================================================================
;; INTEGRATION WITH EVALUATOR
;; ============================================================================

;; Evaluate effect expression in PathFinder syntax
(define/contract (evaluate-effect-expression expr cache)
  (-> constructor-value? constructor-value? effect-result?)
  ;; This would integrate with the main evaluator
  ;; For now, assume expr is already an effect description
  (cached-effect-executor expr cache))